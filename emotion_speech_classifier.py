# -*- coding: utf-8 -*-
"""emotion_speech_classifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qEYKXbii_CUfGV7XUselbRmeQQcGa1Tw
"""

from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
import os
import librosa
import librosa.display
import IPython.display as ipd
import numpy as np
import csv
import pandas as pd
import matplotlib.pyplot as plt

import tensorflow as tf
import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten
from tensorflow.keras.layers import Conv1D, MaxPooling1D, BatchNormalization
from tensorflow.keras.layers import Conv2D, MaxPooling2D
from keras.utils import to_categorical

from google.colab import drive
drive.mount('/content/drive')

"""# Setting up the data with using MFCCs as the features.

"""

# Set the number of MFCCs to extract.
num_mfcc = 20

# Initialize empty arrays to hold the data matrix from audio and corresponding emotion labels.
X = []
y = []

emotions = {"neutral" : 0, "calm" : 1, "happy": 2, "sad": 3, "angry": 4, "fearful": 5, "disgust": 6, "surprised": 7}
emotions_count = {"neutral" : 0, "calm" : 0, "happy": 0, "sad": 0, "angry": 0, "fearful": 0, "disgust": 0, "surprised": 0}
# Iterate through all of the .wav files in our directory.
for file in os.listdir("/content/drive/MyDrive/data"):
  # row =
    if file.endswith(".wav"):
        # Load the audio file using librosa and our files in Google Drive.
        audio_data, sample_rate = librosa.load("/content/drive/MyDrive/data" + "/" + file)

        # Detemine the MFCC features from the audio data provided above.
        mfccs = librosa.feature.mfcc(y=audio_data, sr=sample_rate, n_mfcc=num_mfcc)
        #print(mfccs)

        # Grab the mean of our features.
        mfccs_avg = np.mean(mfccs, axis=1)

        # Add the MFCC features to the data matrix
        X.append(mfccs_avg)

        # Determine the emotion label of the audio file based on its filename.
        name = ""
        idx = 0
        while not (file[idx].isdigit()):
          name += file[idx]
          idx += 1
        emotions_count[name] += 1
        y.append([emotions[name]])

print(emotions_count)

plt.bar(range(len(emotions_count)), list(emotions_count.values()), tick_label = list(emotions_count.keys()))
plt.show()

# Convert our data into np.arrays for SVM.
X = np.array(X)
y = np.array(y)
# print(X.shape)
# print(y.shape)
# print(X)
# print(y)

"""# Model 1: Support Vector Machine


"""

# Initialize the SVM classifier
svm_classifier = SVC(kernel='linear')

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train the SVM classifier on the training data
svm_classifier.fit(X_train, y_train)

# X_test = np.array(X_test)
y_pred = svm_classifier.predict(X_test)

# calculate accuracy score
accuracy_svm = accuracy_score(y_test, y_pred)
print(f"Accuracy score: {accuracy_svm}")

"""# Model 2: Convolutional Neural Networks"""

# split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# reshape input data to have a 3D shape (batch_size, time_steps, input_dim)
X_train = np.expand_dims(X_train, axis=2)
X_test = np.expand_dims(X_test, axis=2)

# create model
model = Sequential()
model.add(Conv1D(32, 3, activation='relu', input_shape=(20, 1)))
model.add(MaxPooling1D(2))
model.add(Conv1D(64, 3, activation='relu'))
model.add(MaxPooling1D(2))
model.add(Conv1D(64, 3, activation='relu'))
model.add(Flatten())
model.add(Dense(64, activation='relu'))
model.add(Dense(8, activation='softmax'))

# compile model
model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# train model
model.fit(X_train, y_train, batch_size=32, epochs=50, validation_data=(X_test, y_test))

"""# Model 3: Random Forest Classifier"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

rf_model = RandomForestClassifier(n_estimators=105, criterion = "log_loss", random_state=42)

# Train model
rf_model.fit(X_train, y_train)

# Predict labels for test set
y_pred = rf_model.predict(X_test)

# Calculate accuracy score
accuracy_rf = accuracy_score(y_test, y_pred)
print(accuracy_rf)

"""# Model 4: Logistic Regression"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train logistic regression model
clf = LogisticRegression(max_iter=10000)
clf.fit(X_train, y_train)

# Get accuracy scores for train and test sets
accuracy_log = accuracy_score(y_test, clf.predict(X_test))
print(accuracy_log)

"""# Plotting Accuracy of Our Models"""

# plot accuracy score
plt.figure(figsize=(8,6))
plt.bar(['Logistic', 'SVM', 'Random Forest'], [accuracy_log, accuracy_svm, accuracy_rf], color = "green")
plt.title('Accuracy of Models for Emotion Recognition')
plt.ylim([0, 1])
plt.ylabel('Accuracy in %')
plt.show()

"""# Testing the Test Data with our Best Model, writing into a CSV file"""

rf_model_true = RandomForestClassifier(n_estimators=105, criterion = "gini", max_features = "sqrt", random_state=42)

# Train model
rf_model_true.fit(X, y)

# Predict the labels of the test data using the trained SVM classifier

file_names = []
X_true_test = []

# Iterate through all of the .wav files in our directory.
for file in os.listdir("/content/drive/MyDrive/test"):
  # row =
    if file.endswith(".wav"):
        split_name = file.split(".")
        file_names.append(split_name[0])
        # Load the audio file using librosa and our files in Google Drive.
        audio_data, sample_rate = librosa.load("/content/drive/MyDrive/test" + "/" + file)

        # Detemine the MFCC features from the audio data provided above.
        mfccs = librosa.feature.mfcc(y=audio_data, sr=sample_rate, n_mfcc=num_mfcc)
        #print(mfccs)

        # Grab the mean of our features.
        mfccs_avg = np.mean(mfccs, axis=1)

        # Add the MFCC features to the data matrix
        X_true_test.append(mfccs_avg)

# predict labels for test set
y_pred = rf_model_true.predict(X_true_test)

emotions_num = {0: "neutral", 1: "calm", 2: "happy", 3: "sad", 4: "angry", 5: "fearful", 6: "disgust", 7: "surprised"}

y_pred_to_strings = []
for idx in range(len(y_pred)):
  y_pred_to_strings.append(emotions_num[y_pred[idx]])

csv_text = [[file_n, pred] for file_n, pred in zip(file_names, y_pred_to_strings)]
csv_text.sort()

with open('predictions.csv', 'w') as f:

    # Create a CSV writer object that will write to the file 'f'
    csv_writer = csv.writer(f)

    # Write the field names (column headers) to the first row of the CSV file
    csv_writer.writerow(["filename", "label"])

    # Write all of the rows of data to the CSV file
    csv_writer.writerows(csv_text)